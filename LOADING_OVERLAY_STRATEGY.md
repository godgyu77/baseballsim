# 🎯 Progressive Streaming 환경에서 로딩 오버레이 전략

## 현재 상황 분석

### 현재 구현
- ✅ Progressive Streaming: 스트리밍 중에도 텍스트가 실시간으로 표시됨
- ✅ LoadingOverlay: `isLoading` 상태에 따라 전체 화면 오버레이 표시
- ⚠️ **문제**: 두 가지가 동시에 표시되어 화면이 복잡해질 수 있음

---

## 옵션 비교

### Option 1: 로딩 오버레이 유지 ❌

#### 장점
- 진행률을 볼 수 있음 (Trickle 알고리즘)
- 초기 로딩 시 피드백 제공
- 상태 텍스트로 진행 상황 표시

#### 단점
- **스트리밍 텍스트를 가림** (전체 화면 오버레이)
- 화면이 복잡해짐
- Progressive Streaming의 목적(실시간 표시)과 충돌
- 사용자가 스트리밍 내용을 보기 어려움

#### 평가: **30/100점** ⭐⭐
- Progressive Streaming의 장점을 상쇄시킴

---

### Option 2: 로딩 오버레이 제거 ✅

#### 장점
- **스트리밍 텍스트를 명확히 볼 수 있음**
- 깔끔한 UI
- Progressive Streaming의 목적에 부합
- 사용자가 실시간으로 내용을 읽을 수 있음

#### 단점
- 초기 로딩(첫 chunk 도착 전)에는 피드백이 없을 수 있음
- 진행률을 볼 수 없음

#### 평가: **70/100점** ⭐⭐⭐⭐
- Progressive Streaming의 장점을 최대한 활용

---

### Option 3: 하이브리드 접근 (권장) ✅✅

#### 전략
1. **초기 로딩 단계**: 첫 chunk 도착 전까지 로딩 오버레이 표시
2. **스트리밍 시작**: 첫 chunk 도착 시 로딩 오버레이 숨김
3. **스트리밍 중**: 텍스트만 표시 (스트리밍 인디케이터 포함)

#### 장점
- ✅ 초기 피드백 제공 (첫 chunk 도착 전)
- ✅ 스트리밍 중에는 내용을 명확히 볼 수 있음
- ✅ Progressive Streaming의 장점 최대 활용
- ✅ 사용자 경험 최적화

#### 단점
- 구현 복잡도 약간 증가

#### 평가: **95/100점** ⭐⭐⭐⭐⭐
- **가장 권장되는 방식**

---

## 🎯 최종 추천: **Option 3 (하이브리드 접근)**

### 구현 방법

```typescript
// 스트리밍 시작 플래그
const [hasStartedStreaming, setHasStartedStreaming] = useState(false);

// 첫 chunk 도착 시
for await (const chunk of result.stream) {
  if (!hasStartedStreaming) {
    setHasStartedStreaming(true);
    setIsLoading(false); // 로딩 오버레이 숨김
  }
  
  // 스트리밍 텍스트 업데이트
  // ...
}
```

### 사용자 경험 흐름

1. **0-0.5초**: 로딩 오버레이 표시 (초기 피드백)
2. **0.5초**: 첫 chunk 도착 → 로딩 오버레이 숨김
3. **0.5초 이후**: 스트리밍 텍스트가 점진적으로 표시됨
4. **완료**: 스트리밍 인디케이터 제거

---

## 📊 비교표

| 항목 | Option 1 (유지) | Option 2 (제거) | Option 3 (하이브리드) |
|------|----------------|----------------|---------------------|
| 초기 피드백 | ✅ | ❌ | ✅ |
| 스트리밍 가시성 | ❌ | ✅ | ✅ |
| 진행률 표시 | ✅ | ❌ | ⚠️ (초기만) |
| UI 깔끔함 | ❌ | ✅ | ✅ |
| 구현 복잡도 | 낮음 | 낮음 | 중간 |
| **종합 점수** | 30/100 | 70/100 | **95/100** |

---

## ✅ 결론

**Option 3 (하이브리드 접근)**을 권장합니다:
- 초기 로딩 시 피드백 제공
- 스트리밍 중에는 내용을 명확히 볼 수 있음
- Progressive Streaming의 장점을 최대한 활용
- 최적의 사용자 경험 제공

